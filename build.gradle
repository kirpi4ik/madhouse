buildscript {
    repositories {
        mavenLocal()
        maven { url "https://repo.grails.org/grails/core" }
        maven { url "https://repo1.maven.org/maven2" }
    }
    dependencies {
        classpath 'com.bmuschko:gradle-docker-plugin:6.1.3'
        classpath 'commons-io:commons-io:2.6'
    }
}
plugins {
    id "com.bmuschko.docker-remote-api" version "6.1.3"
    id 'java-library'
}
//tag::extVariables[]
ext {
    projectVersion = "2.0.2"
    dockerTag = "madhouse/${project.name}:${projectVersion}".toLowerCase() // <1>
    dockerBuildDir = mkdir("${buildDir}/docker")
    dockerContainerName = 'madhousev2'
    dockerBuildGroup = 'Docker'
}
//end::extVariables[]
subprojects { project ->
    version projectVersion
    group "eu.devexpert.madhouse"
}

task copyClientResources(dependsOn: ':web-vue:build') { // <1>
    group = 'build'
    description = 'Copy client resources into server'
}

task assembleServerAndClient(dependsOn: ['copyClientResources', ':server-core:assemble']) { // <2>
    group = 'build'
    description = 'Build combined server & web-vue JAR/WAR'

    doLast {
        copy {
            from fileTree(dir: "${project(':server-core').buildDir}/libs/") // <3>
            into "$rootDir/build/"
        }

        logger.quiet "JAR/WAR generated at $rootDir/build/. It combines the server and web-vue projects."
    }
}

copyClientResources.doFirst { // <4>
    copy {
        from "${project(':web-vue').projectDir}/dist"
        into "${project(':server-core').buildDir}/resources/main/public"
    }
}
//tag::import[]
import org.apache.commons.io.FilenameUtils
import com.bmuschko.gradle.docker.tasks.image.Dockerfile
import com.bmuschko.gradle.docker.tasks.image.DockerBuildImage
import com.bmuschko.gradle.docker.tasks.image.DockerRemoveImage
import com.bmuschko.gradle.docker.tasks.container.DockerCreateContainer
import com.bmuschko.gradle.docker.tasks.container.DockerStartContainer
import com.bmuschko.gradle.docker.tasks.container.DockerStopContainer
import com.bmuschko.gradle.docker.tasks.container.DockerRemoveContainer

//end::import[]

docker {
    url = 'http://localhost:2375'
//    certPath = new File(System.properties['user.home'], '.boot2docker/certs/boot2docker-vm')

    registryCredentials {
        url = 'https://index.docker.io/v1/'
        username = 'kirpi4ik'
        password = 'j8FkX01Xs2PfvQhnrWBk'
        email = 'dumitru.ciubenco@gmail.com'
    }
}
//tag::prepareDocker[]
task prepareDocker(type: Copy, dependsOn: assembleServerAndClient) { // <3>
    description = 'Copy files from src/main/docker and application jar to Docker temporal build directory'
    group = dockerBuildGroup
    copy {
        from 'src/main/docker'
        into dockerBuildDir
    }
    copy {
        from "${buildDir}/madhouse-${projectVersion}.jar"
        into dockerBuildDir
    }
}
//end::prepareDocker[]

//tag::createDockerfile[]
task createDockerfile(type: Dockerfile, dependsOn: prepareDocker) { // <4>
    description = 'Create a Dockerfile file'
    group = dockerBuildGroup

    destFile = project.file("${dockerBuildDir}/Dockerfile")

    from 'openjdk:8u151-jdk-alpine'

    exposePort 8080
    environmentVariable 'GRAILS_ENV', 'production'
    // Create a config directory and expose as volume.
    // External configuration files in this volume are automatically
    // picked up.
    runCommand 'mkdir -p /app/config'
    volume '/app/config'
    workingDir '/app'

    copyFile "madhouse-${projectVersion}.jar", 'madhouse.jar'
    copyFile 'app-entrypoint.sh', 'app-entrypoint.sh' // <5>
    runCommand 'chmod +x app-entrypoint.sh'

    entryPoint '/app/app-entrypoint.sh' // <5>
}
//end::createDockerfile[]

//tag::buildImage[]

task buildImage(type: DockerBuildImage, dependsOn: createDockerfile) { // <6>
    description = 'Create Docker image to run the Grails application'
    group = dockerBuildGroup

    inputDir = file(dockerBuildDir)
    images.add(dockerTag)
}
//end::buildImage[]
task removeImage(type: DockerRemoveImage) {
    description = 'Remove Docker image with Grails application.'
    group = dockerBuildGroup

    targetImageId { dockerTag }
}

//------------------------------------------------------------------------------
// Extra tasks to create, run, stop and remove containers
// for a development and production environment.
//------------------------------------------------------------------------------
['development', 'production'].each { environment ->

    // Transform environment for use in task names.
    final String taskName = environment.capitalize()

    // Name for container contains the environment name.
    final String name = "${dockerContainerName}-${environment}"

    task "createContainer$taskName"(type: DockerCreateContainer) {
        description = "Create Docker container $name with grails.env $environment."
        group = dockerBuildGroup

        targetImageId { dockerTag }
        containerName = name

        exposePorts("tcp", [8080])
        // Expose port 8080 from container to outside as port 8080.
        hostConfig.portBindings = ['8080:8080']
        hostConfig.autoRemove = true
        hostConfig.links = ["madhousev2-db:database"]

        // The image has a volume /app/config for external configuration
        // files that are automatically picked up by the Grails application.
        // In this example we use a local directory with configuration files
        // on our host and bind it to the volume in the container.
        String projectIsDir = "/host_mnt/${FilenameUtils.separatorsToUnix(projectDir.absolutePath).replaceAll(":", "")}/src/main/deployment/${environment}"
        println projectIsDir
        hostConfig.binds = ["${projectIsDir}": '/app/config']
        tty = false

        // Set environment variable GRAILS_ENV to environment value.
        // The docker-entrypoint.sh script picks up this environment
        // variable and turns it into Java system property
        // -Dgrails.env.
        withEnvVar("GRAILS_ENV", "$environment")

        // Example of adding extra command line arguments to the
        // java -jar app.jar that is executed in the container.
        cmd = ["--app.dockerContainerName=${containerName}"]
    }
    task "startContainer$taskName"(type: DockerStartContainer) {
        description = "Start Docker container $name."
        group = dockerBuildGroup

        targetContainerId { name }
    }

    task "stopContainer$taskName"(type: DockerStopContainer) {
        description = "Stop Docker container $name."
        group = dockerBuildGroup

        targetContainerId { name }
    }

    task "removeContainer$taskName"(type: DockerRemoveContainer) {
        description = "Remove Docker container $name."
        group = dockerBuildGroup

        targetContainerId { name }
    }
}